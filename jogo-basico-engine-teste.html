<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Teste Básico da Engine - Pixlland</title>
  <style>
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0b1020;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      color: #e6edf3;
    }

    #application {
      width: 100%;
      height: 100%;
      display: block;
    }

    .hud {
      position: fixed;
      top: 12px;
      left: 12px;
      background: rgba(0, 0, 0, 0.45);
      padding: 10px 12px;
      border-radius: 10px;
      line-height: 1.45;
      font-size: 14px;
      user-select: none;
      min-width: 220px;
      backdrop-filter: blur(4px);
    }

    .ok {
      color: #4ade80;
      font-weight: 600;
    }

    .warn {
      color: #fbbf24;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <canvas id="application"></canvas>

  <div class="hud" id="hud">
    <div><strong>Teste da Engine</strong></div>
    <div id="status">Status: iniciando...</div>
    <div id="score">Pontos: 0</div>
    <div id="miss">Erros: 0 / 5</div>
    <div style="margin-top: 6px; opacity: .9;">Mover: ← → ou A D</div>
    <div style="opacity: .9;">Reiniciar: R</div>
  </div>

  <script src="./engine/build/playcanvas.js"></script>
  <script>
    const canvas = document.getElementById('application');
    const hudStatus = document.getElementById('status');
    const hudScore = document.getElementById('score');
    const hudMiss = document.getElementById('miss');

    const app = new pc.Application(canvas, {
      keyboard: new pc.Keyboard(window),
      mouse: new pc.Mouse(canvas),
      touch: pc.platform.touch ? new pc.TouchDevice(canvas) : null
    });

    app.start();
    app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
    app.setCanvasResolution(pc.RESOLUTION_AUTO);
    window.addEventListener('resize', () => app.resizeCanvas());

    app.scene.ambientLight = new pc.Color(0.25, 0.3, 0.38);

    const camera = new pc.Entity('Camera');
    camera.addComponent('camera', {
      clearColor: new pc.Color(0.06, 0.09, 0.16)
    });
    camera.setLocalPosition(0, 10, 16);
    camera.lookAt(0, 0, 0);
    app.root.addChild(camera);

    const light = new pc.Entity('Light');
    light.addComponent('light', {
      type: 'directional',
      intensity: 1.5,
      castShadows: true,
      shadowResolution: 1024,
      shadowDistance: 30
    });
    light.setLocalEulerAngles(50, 35, 0);
    app.root.addChild(light);

    const ground = new pc.Entity('Ground');
    ground.addComponent('render', {
      type: 'box'
    });
    ground.setLocalScale(14, 0.25, 18);
    ground.setLocalPosition(0, -0.12, 0);
    app.root.addChild(ground);

    const player = new pc.Entity('Player');
    player.addComponent('render', {
      type: 'box'
    });
    player.setLocalScale(1.3, 0.8, 1.3);
    player.setLocalPosition(0, 0.4, 5.5);
    app.root.addChild(player);

    const playerMaterial = new pc.StandardMaterial();
    playerMaterial.diffuse = new pc.Color(0.35, 0.82, 0.98);
    playerMaterial.metalness = 0.15;
    playerMaterial.useMetalness = true;
    playerMaterial.update();
    player.render.material = playerMaterial;

    const orbMaterial = new pc.StandardMaterial();
    orbMaterial.diffuse = new pc.Color(1, 0.72, 0.2);
    orbMaterial.emissive = new pc.Color(0.25, 0.15, 0.03);
    orbMaterial.update();

    let score = 0;
    let misses = 0;
    let spawnTimer = 0;
    let gameOver = false;
    const maxMisses = 5;
    const minX = -5.8;
    const maxX = 5.8;
    const playerSpeed = 7;
    const orbs = [];

    const setStatus = (text, ok = true) => {
      hudStatus.innerHTML = `Status: <span class="${ok ? 'ok' : 'warn'}">${text}</span>`;
    };

    const refreshHud = () => {
      hudScore.textContent = `Pontos: ${score}`;
      hudMiss.textContent = `Erros: ${misses} / ${maxMisses}`;
    };

    const spawnOrb = () => {
      const orb = new pc.Entity('Orb');
      orb.addComponent('render', { type: 'sphere' });
      orb.render.material = orbMaterial;
      orb.setLocalScale(0.6, 0.6, 0.6);
      orb.setLocalPosition(pc.math.lerp(minX, maxX, Math.random()), 0.5, -8.5);
      orb.speed = 3.3 + Math.random() * 1.8;
      app.root.addChild(orb);
      orbs.push(orb);
    };

    const resetGame = () => {
      for (let i = 0; i < orbs.length; i++) {
        if (orbs[i].parent) {
          orbs[i].destroy();
        }
      }
      orbs.length = 0;
      score = 0;
      misses = 0;
      spawnTimer = 0;
      gameOver = false;
      player.setLocalPosition(0, 0.4, 5.5);
      refreshHud();
      setStatus('rodando', true);
    };

    resetGame();

    app.on('update', (dt) => {
      if (app.keyboard.wasPressed(pc.KEY_R)) {
        resetGame();
      }

      if (gameOver) {
        return;
      }

      let dir = 0;
      if (app.keyboard.isPressed(pc.KEY_LEFT) || app.keyboard.isPressed(pc.KEY_A)) {
        dir -= 1;
      }
      if (app.keyboard.isPressed(pc.KEY_RIGHT) || app.keyboard.isPressed(pc.KEY_D)) {
        dir += 1;
      }

      if (dir !== 0) {
        const pos = player.getLocalPosition();
        pos.x = pc.math.clamp(pos.x + dir * playerSpeed * dt, minX, maxX);
        player.setLocalPosition(pos);
      }

      spawnTimer -= dt;
      if (spawnTimer <= 0) {
        spawnOrb();
        spawnTimer = 0.45 + Math.random() * 0.35;
      }

      const playerPos = player.getLocalPosition();

      for (let i = orbs.length - 1; i >= 0; i--) {
        const orb = orbs[i];
        if (!orb || !orb.parent) {
          orbs.splice(i, 1);
          continue;
        }

        const p = orb.getLocalPosition();
        p.z += orb.speed * dt;
        orb.setLocalPosition(p);
        orb.rotate(40 * dt, 80 * dt, 30 * dt);

        const dx = p.x - playerPos.x;
        const dz = p.z - playerPos.z;
        const dist2 = dx * dx + dz * dz;

        if (dist2 < 1.1) {
          score += 1;
          orb.destroy();
          orbs.splice(i, 1);
          refreshHud();
          continue;
        }

        if (p.z > 8.5) {
          misses += 1;
          orb.destroy();
          orbs.splice(i, 1);
          refreshHud();
          if (misses >= maxMisses) {
            gameOver = true;
            setStatus('fim de jogo (pressione R para reiniciar)', false);
          }
        }
      }
    });

    setStatus('rodando', true);
  </script>
</body>
</html>
