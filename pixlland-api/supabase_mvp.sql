-- Pixlland MVP schema for Supabase
-- Run in Supabase SQL editor

-- Extensions
create extension if not exists "uuid-ossp";

-- Profiles
create table if not exists public.users_profile (
  id uuid primary key references auth.users(id) on delete cascade,
  username text unique,
  full_name text,
  avatar_url text,
  flags jsonb default '{}'::jsonb,
  created_at timestamptz default now()
);

-- Projects
create table if not exists public.projects (
  id bigint generated by default as identity primary key,
  owner_id uuid not null references auth.users(id) on delete cascade,
  name text not null,
  description text default '',
  private boolean default true,
  settings jsonb default '{}'::jsonb,
  created_at timestamptz default now()
);

create table if not exists public.project_collaborators (
  project_id bigint not null references public.projects(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  access_level text not null default 'write',
  created_at timestamptz default now(),
  primary key (project_id, user_id)
);

-- Branches
create table if not exists public.branches (
  id uuid primary key default uuid_generate_v4(),
  project_id bigint not null references public.projects(id) on delete cascade,
  name text not null,
  is_master boolean default false,
  created_by uuid references auth.users(id) on delete set null,
  created_at timestamptz default now()
);

-- Scenes
create table if not exists public.scenes (
  id bigint generated by default as identity primary key,
  project_id bigint not null references public.projects(id) on delete cascade,
  branch_id uuid not null references public.branches(id) on delete cascade,
  name text not null,
  unique_id uuid default uuid_generate_v4(),
  owner_id uuid not null references auth.users(id) on delete cascade,
  created_at timestamptz default now()
);

-- Assets
create table if not exists public.assets (
  id bigint generated by default as identity primary key,
  project_id bigint not null references public.projects(id) on delete cascade,
  branch_id uuid not null references public.branches(id) on delete cascade,
  name text not null,
  type text not null,
  file jsonb default '{}'::jsonb,
  data jsonb default '{}'::jsonb,
  owner_id uuid not null references auth.users(id) on delete cascade,
  created_at timestamptz default now()
);

-- Jobs (optional MVP)
create table if not exists public.jobs (
  id bigint generated by default as identity primary key,
  project_id bigint not null references public.projects(id) on delete cascade,
  type text not null,
  status text not null default 'pending',
  logs text,
  created_at timestamptz default now()
);

-- RLS
alter table public.users_profile enable row level security;
alter table public.projects enable row level security;
alter table public.project_collaborators enable row level security;
alter table public.branches enable row level security;
alter table public.scenes enable row level security;
alter table public.assets enable row level security;
alter table public.jobs enable row level security;

-- Policies: users_profile
create policy "profile_read_own" on public.users_profile
  for select using (id = auth.uid());

create policy "profile_update_own" on public.users_profile
  for update using (id = auth.uid());

create policy "profile_insert_own" on public.users_profile
  for insert with check (id = auth.uid());

-- Policies: projects
create policy "projects_read_owner_or_collab" on public.projects
  for select using (
    owner_id = auth.uid()
    or exists (
      select 1 from public.project_collaborators pc
      where pc.project_id = projects.id and pc.user_id = auth.uid()
    )
  );

create policy "projects_insert_owner" on public.projects
  for insert with check (owner_id = auth.uid());

create policy "projects_update_owner" on public.projects
  for update using (owner_id = auth.uid());

create policy "projects_delete_owner" on public.projects
  for delete using (owner_id = auth.uid());

-- Policies: project_collaborators
create policy "collab_read_owner_or_self" on public.project_collaborators
  for select using (
    user_id = auth.uid()
    or exists (
      select 1 from public.projects p
      where p.id = project_collaborators.project_id and p.owner_id = auth.uid()
    )
  );

create policy "collab_insert_owner" on public.project_collaborators
  for insert with check (
    exists (
      select 1 from public.projects p
      where p.id = project_collaborators.project_id and p.owner_id = auth.uid()
    )
  );

create policy "collab_delete_owner" on public.project_collaborators
  for delete using (
    exists (
      select 1 from public.projects p
      where p.id = project_collaborators.project_id and p.owner_id = auth.uid()
    )
  );

-- Policies: branches
create policy "branches_read_project" on public.branches
  for select using (
    exists (
      select 1 from public.projects p
      where p.id = branches.project_id and (
        p.owner_id = auth.uid()
        or exists (
          select 1 from public.project_collaborators pc
          where pc.project_id = p.id and pc.user_id = auth.uid()
        )
      )
    )
  );

create policy "branches_insert_owner" on public.branches
  for insert with check (
    exists (
      select 1 from public.projects p
      where p.id = branches.project_id and p.owner_id = auth.uid()
    )
  );

create policy "branches_update_owner" on public.branches
  for update using (
    exists (
      select 1 from public.projects p
      where p.id = branches.project_id and p.owner_id = auth.uid()
    )
  );

create policy "branches_delete_owner" on public.branches
  for delete using (
    exists (
      select 1 from public.projects p
      where p.id = branches.project_id and p.owner_id = auth.uid()
    )
  );

-- Policies: scenes
create policy "scenes_read_project" on public.scenes
  for select using (
    exists (
      select 1 from public.projects p
      where p.id = scenes.project_id and (
        p.owner_id = auth.uid()
        or exists (
          select 1 from public.project_collaborators pc
          where pc.project_id = p.id and pc.user_id = auth.uid()
        )
      )
    )
  );

create policy "scenes_insert_owner" on public.scenes
  for insert with check (owner_id = auth.uid());

create policy "scenes_update_owner" on public.scenes
  for update using (owner_id = auth.uid());

create policy "scenes_delete_owner" on public.scenes
  for delete using (owner_id = auth.uid());

-- Policies: assets
create policy "assets_read_project" on public.assets
  for select using (
    exists (
      select 1 from public.projects p
      where p.id = assets.project_id and (
        p.owner_id = auth.uid()
        or exists (
          select 1 from public.project_collaborators pc
          where pc.project_id = p.id and pc.user_id = auth.uid()
        )
      )
    )
  );

create policy "assets_insert_owner" on public.assets
  for insert with check (owner_id = auth.uid());

create policy "assets_update_owner" on public.assets
  for update using (owner_id = auth.uid());

create policy "assets_delete_owner" on public.assets
  for delete using (owner_id = auth.uid());

-- Policies: jobs
create policy "jobs_read_project" on public.jobs
  for select using (
    exists (
      select 1 from public.projects p
      where p.id = jobs.project_id and (
        p.owner_id = auth.uid()
        or exists (
          select 1 from public.project_collaborators pc
          where pc.project_id = p.id and pc.user_id = auth.uid()
        )
      )
    )
  );

create policy "jobs_insert_owner" on public.jobs
  for insert with check (
    exists (
      select 1 from public.projects p
      where p.id = jobs.project_id and p.owner_id = auth.uid()
    )
  );

create policy "jobs_update_owner" on public.jobs
  for update using (
    exists (
      select 1 from public.projects p
      where p.id = jobs.project_id and p.owner_id = auth.uid()
    )
  );

create policy "jobs_delete_owner" on public.jobs
  for delete using (
    exists (
      select 1 from public.projects p
      where p.id = jobs.project_id and p.owner_id = auth.uid()
    )
  );
